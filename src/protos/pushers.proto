syntax = "proto3";

/*************************************************/
/******** Main messages that will be sent ********/
/*************************************************/

// Configuration details that may or may not require a reboot to implement
message PusherConfig {
    PusherType type = 1;
    int32 extendPin = 2;
    bool canBrake = 3;
    // Can be skipped if CanBrake == false
    int32 brakePin = 4;
    // This input can be used for cycle control switches; it's also acceptable to have no control inputs
    repeated PusherControlInput controlInputs = 5;

    oneof PusherTimings{
        MotorTimings motorTiming = 6;
        SolenoidTimings solenoidTiming = 7;
    }
}

// Parameters that can be changed on the fly without needing a reboot
message PusherParams {
    int32 rateOfFire = 1;
    // A repeating list of burst lengths will let users configure any number and order of firing patterns that they'd
    //  like (within reason; we'll probably need to cap the list at something reasonable).
    // A burst length of 0 is safe, 1 is semi-auto, 255 is full auto, and anything in between is a valid (if silly)
    //  burst length
    // The user could then cycle between the burst lengths with a button, rotaty dial, etc that the user defines in the
    //  controls proto
    repeated PusherBurstEntry burstEntries = 2;
}

/*************************************************/
/************** Enums and sub-types **************/
/*************************************************/

enum PusherType {
    PUSHER_MOTOR_CLOSEDLOOP = 0;
    PUSHER_SOLENOID_CLOSEDLOOP = 1;
    // Do we want to support open loop motor pushers?
    PUSHER_MOTOR_OPENLOOP = 2;
    PUSHER_SOLENOID_OPENLOOP = 3;
}

message PusherControlInput {
    PusherControlInputType Type = 1;
    int32 DataPin = 2;
}

enum PusherControlInputType {
    PUSHER_UNSPECIFIED = 0;
    PUSHER_REARMOST = 1;
    PUSHER_FOREMOST = 2;
    // This may need more than 1 pin, or some sort of enum for how it's controlled, this would probaby be fine if we
    //  just need an i2c address or something
    PUSHER_POSITION = 3;
}

message MotorTimings {
    // The maximum amount of time the pusher should take to transition between stages
    // If we have foremost and rearmost switched, then the maximum amount of time an extension or retraction can take
    // If we only have rearmost, the maximum amount of time it can take to complete a cycle
    // If we lack control inputs, this is undefined
    int32 stallTime_ms = 1;
}

message SolenoidTimings {
    // The maximum amount of time the pusher will be extended
    // If we have a foremost control intput and we don't see it trigger in this time, we have a jam and will attempt
    //  to fix or alert the user
    // Is there any case (like single fire or firemode 1) where we'd want the pusher to stay extended while the user holds down the trigger?
    int32 maxExtendTime = 1;
    // The minium amount of time the plunger must be retracting before the system can fire again
    // If we have a rearmost control input and we don't see it trigger in this time, we have a jam and will attempt
    //  to fix or alert the user
    int32 minRetractTime = 2;
}
