syntax = "proto3";

/*************************************************/
/******** Main messages that will be sent ********/
/*************************************************/

// Configuration details that may or may not require a reboot to implement
message PusherConfig {
    PusherType type = 0;
    int32 ExtendPin = 1;
    bool CanBrake = 2;
    // Can be skipped if CanBrake == false
    int32 BrakePin = 3;
    // This input can be used for cycle control switches; it's also acceptable to have no control inputs
    repeated PusherControlInput = 4;

    oneof PusherTimings{
        MotorTimings = 5;
        SolenoidTimings = 6;
    }
}

// Parameters that can be changed on the fly without needing a reboot
message PusherParams {
    int32 RateOfFire = 0;
    // A repeating list of burst lengths will let users configure any number and order of firing patterns that they'd
    //  like (within reason; we'll probably need to cap the list at something reasonable).
    // A burst length of 0 is safe, 1 is semi-auto, 255 is full auto, and anything in between is a valid (if silly)
    //  burst length
    // The user could then cycle between the burst lengths with a button, rotaty dial, etc that the user defines in the
    //  controls proto
    repeated PusherBurstEntry BurstEntries = 1;
}

/*************************************************/
/************** Enums and sub-types **************/
/*************************************************/

enum PusherType {
    PUSHER_MOTOR_CLOSEDLOOP = 0;
    PUSHER_SOLENOID_CLOSEDLOOP = 1;
    // Do we want to support open loop motor pushers?
    PUSHER_MOTOR_OPENLOOP = 2;
    PUSHER_SOLENOID_OPENLOOP = 3;
}

message PusherControlInput {
    enum PusherControlInputType = 0;
    int32 DataPin = 1;
}

enum PusherControlInputType {
    PUSHER_UNSPECIFIED = 0;
    PUSHER_REARMOST = 1;
    PUSHER_FOREMOST = 2;
    // This may need more than 1 pin, or some sort of enum for how it's controlled, this would probaby be fine if we
    //  just need an i2c address or something
    PUSHER_POSITION = 3;
}

message PusherBurstEntry {
    int32 Length = 0;
    PusherBurstType Type = 1;
}

enum PusherBurstType {
    // The pusher will stop as soon as the current cycle completes, even if it's short of the burst count
    PUSHER_BURST_STOP = 0;
    // The pusher will stop after it has fired the current n-dart burst
    PUSHER_BURST_COMPLETE = 1;
    // The pusher will count the number of times the trigger has been released and fire that many bursts

    // or is _QUEUE a better descriptor of what this is?
    PUSHER_BURST_COUNT = 2;
}

message MotorTimings {
    // The maximum amount of time the pusher should take to transition between stages
    // If we have foremost and rearmost switched, then the maximum amount of time an extension or retraction can take
    // If we only have rearmost, the maximum amount of time it can take to complete a cycle
    // If we lack control inputs, this is undefined
    int32 stallTime_ms = 0;
}

message SolenoidTimings {
    // The maximum amount of time the pusher will be extended
    // If we have a foremost control intput and we don't see it trigger in this time, we have a jam and will attempt
    //  to fix or alert the user
    // Is there any case (like single fire or firemode 1) where we'd want the pusher to stay extended while the user holds down the trigger?
    int32 maxExtendTime = 0;
    // The minium amount of time the plunger must be retracting before the system can fire again
    // If we have a rearmost control input and we don't see it trigger in this time, we have a jam and will attempt
    //  to fix or alert the user
    int32 minRetractTime = 1;
}